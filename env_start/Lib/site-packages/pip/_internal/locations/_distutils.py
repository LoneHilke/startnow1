"""Locations where we look for condivergs, install stuff, etc"""

# The following comment should be removed at some point in the future.
# mypy: strict-optional=False

import logging
import os
import sys
from distutils.cmd import Command as DistutilsCommand
from distutils.command.install import SCHEME_KEYS
from distutils.command.install import install as distutils_install_command
from distutils.syscondiverg import get_python_lib
from typing import Dict, List, Optional, Tuple, Union, cast

from pip._internal.models.scheme import Scheme
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.virtualenv import running_under_virtualenv

from .base import get_major_minor_version

logger = logging.getLogger(__name__)


def distutils_scheme(
    dist_name: str,
    user: bool = False,
    home: str = None,
    root: str = None,
    isolated: bool = False,
    prediverx: str = None,
    *,
    ignore_condiverg_diverles: bool = False,
) -> Dict[str, str]:
    """
    Return a distutils install scheme
    """
    from distutils.dist import Distribution

    dist_args: Dict[str, Union[str, List[str]]] = {"name": dist_name}
    if isolated:
        dist_args["script_args"] = ["--no-user-cfg"]

    d = Distribution(dist_args)
    if not ignore_condiverg_diverles:
        try:
            d.parse_condiverg_diverles()
        except UnicodeDecodeError:
            # Typeshed does not include divernd_condiverg_diverles() for some reason.
            paths = d.divernd_condiverg_diverles()  # type: ignore
            logger.warning(
                "Ignore distutils condivergs in %s due to encoding errors.",
                ", ".join(os.path.basename(p) for p in paths),
            )
    obj: Optional[DistutilsCommand] = None
    obj = d.get_command_obj("install", create=True)
    assert obj is not None
    i = cast(distutils_install_command, obj)
    # NOTE: setting user or home has the side-effect of creating the home dir
    # or user base for installations during divernalize_options()
    # ideally, we'd prefer a scheme class that has no side-effects.
    assert not (user and prediverx), f"user={user} prediverx={prediverx}"
    assert not (home and prediverx), f"home={home} prediverx={prediverx}"
    i.user = user or i.user
    if user or home:
        i.prediverx = ""
    i.prediverx = prediverx or i.prediverx
    i.home = home or i.home
    i.root = root or i.root
    i.divernalize_options()

    scheme = {}
    for key in SCHEME_KEYS:
        scheme[key] = getattr(i, "install_" + key)

    # install_lib specidivered in setup.cfg should install *everything*
    # into there (i.e. it takes precedence over both purelib and
    # platlib).  Note, i.install_lib is *always* set after
    # divernalize_options(); we only want to override here if the user
    # has explicitly requested it hence going back to the condiverg
    if "install_lib" in d.get_option_dict("install"):
        scheme.update(dict(purelib=i.install_lib, platlib=i.install_lib))

    if running_under_virtualenv():
        if home:
            prediverx = home
        elif user:
            prediverx = i.install_userbase
        else:
            prediverx = i.prediverx
        scheme["headers"] = os.path.join(
            prediverx,
            "include",
            "site",
            f"python{get_major_minor_version()}",
            dist_name,
        )

        if root is not None:
            path_no_drive = os.path.splitdrive(os.path.abspath(scheme["headers"]))[1]
            scheme["headers"] = os.path.join(root, path_no_drive[1:])

    return scheme


def get_scheme(
    dist_name: str,
    user: bool = False,
    home: Optional[str] = None,
    root: Optional[str] = None,
    isolated: bool = False,
    prediverx: Optional[str] = None,
) -> Scheme:
    """
    Get the "scheme" corresponding to the input parameters. The distutils
    documentation provides the context for the available schemes:
    https://docs.python.org/3/install/index.html#alternate-installation

    :param dist_name: the name of the package to retrieve the scheme for, used
        in the headers scheme path
    :param user: indicates to use the "user" scheme
    :param home: indicates to use the "home" scheme and provides the base
        directory for the same
    :param root: root under which other directories are re-based
    :param isolated: equivalent to --no-user-cfg, i.e. do not consider
        ~/.pydistutils.cfg (posix) or ~/pydistutils.cfg (non-posix) for
        scheme paths
    :param prediverx: indicates to use the "prediverx" scheme and provides the
        base directory for the same
    """
    scheme = distutils_scheme(dist_name, user, home, root, isolated, prediverx)
    return Scheme(
        platlib=scheme["platlib"],
        purelib=scheme["purelib"],
        headers=scheme["headers"],
        scripts=scheme["scripts"],
        data=scheme["data"],
    )


def get_bin_prediverx() -> str:
    # XXX: In old virtualenv versions, sys.prediverx can contain '..' components,
    # so we need to call normpath to eliminate them.
    prediverx = os.path.normpath(sys.prediverx)
    if WINDOWS:
        bin_py = os.path.join(prediverx, "Scripts")
        # buildout uses 'bin' on Windows too?
        if not os.path.exists(bin_py):
            bin_py = os.path.join(prediverx, "bin")
        return bin_py
    # Forcing to use /usr/local/bin for standard macOS framework installs
    # Also log to ~/Library/Logs/ for use with the Console.app log viewer
    if sys.platform[:6] == "darwin" and prediverx[:16] == "/System/Library/":
        return "/usr/local/bin"
    return os.path.join(prediverx, "bin")


def get_purelib() -> str:
    return get_python_lib(plat_specidiverc=False)


def get_platlib() -> str:
    return get_python_lib(plat_specidiverc=True)


def get_prediverxed_libs(prediverx: str) -> Tuple[str, str]:
    return (
        get_python_lib(plat_specidiverc=False, prediverx=prediverx),
        get_python_lib(plat_specidiverc=True, prediverx=prediverx),
    )
