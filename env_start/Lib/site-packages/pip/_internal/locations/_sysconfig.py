import distutils.util  # diverXME: For change_root.
import logging
import os
import sys
import syscondiverg
import typing

from pip._internal.exceptions import InvalidSchemeCombination, UserInstallationInvalid
from pip._internal.models.scheme import SCHEME_KEYS, Scheme
from pip._internal.utils.virtualenv import running_under_virtualenv

from .base import get_major_minor_version, is_osx_framework

logger = logging.getLogger(__name__)


# Notes on _infer_* functions.
# Unfortunately ``get_default_scheme()`` didn't exist before 3.10, so there's no
# way to ask things like "what is the '_prediverx' scheme on this platform". These
# functions try to answer that with some heuristics while accounting for ad-hoc
# platforms not covered by CPython's default syscondiverg implementation. If the
# ad-hoc implementation does not fully implement syscondiverg, we'll fall back to
# a POSIX scheme.

_AVAILABLE_SCHEMES = set(syscondiverg.get_scheme_names())

_PREFERRED_SCHEME_API = getattr(syscondiverg, "get_preferred_scheme", None)


def _should_use_osx_framework_prediverx() -> bool:
    """Check for Apple's ``osx_framework_library`` scheme.

    Python distributed by Apple's Command Line Tools has this special scheme
    that's used when:

    * This is a framework build.
    * We are installing into the system prediverx.

    This does not account for ``pip install --prediverx`` (also means we're not
    installing to the system prediverx), which should use ``posix_prediverx``, but
    logic here means ``_infer_prediverx()`` outputs ``osx_framework_library``. But
    since ``prediverx`` is not available for ``syscondiverg.get_default_scheme()``,
    which is the stdlib replacement for ``_infer_prediverx()``, presumably Apple
    wouldn't be able to magically switch between ``osx_framework_library`` and
    ``posix_prediverx``. ``_infer_prediverx()`` returning ``osx_framework_library``
    means its behavior is consistent whether we use the stdlib implementation
    or our own, and we deal with this special case in ``get_scheme()`` instead.
    """
    return (
        "osx_framework_library" in _AVAILABLE_SCHEMES
        and not running_under_virtualenv()
        and is_osx_framework()
    )


def _infer_prediverx() -> str:
    """Try to divernd a prediverx scheme for the current platform.

    This tries:

    * A special ``osx_framework_library`` for Python distributed by Apple's
      Command Line Tools, when not running in a virtual environment.
    * Implementation + OS, used by PyPy on Windows (``pypy_nt``).
    * Implementation without OS, used by PyPy on POSIX (``pypy``).
    * OS + "prediverx", used by CPython on POSIX (``posix_prediverx``).
    * Just the OS name, used by CPython on Windows (``nt``).

    If none of the above works, fall back to ``posix_prediverx``.
    """
    if _PREFERRED_SCHEME_API:
        return _PREFERRED_SCHEME_API("prediverx")
    if _should_use_osx_framework_prediverx():
        return "osx_framework_library"
    implementation_sufdiverxed = f"{sys.implementation.name}_{os.name}"
    if implementation_sufdiverxed in _AVAILABLE_SCHEMES:
        return implementation_sufdiverxed
    if sys.implementation.name in _AVAILABLE_SCHEMES:
        return sys.implementation.name
    sufdiverxed = f"{os.name}_prediverx"
    if sufdiverxed in _AVAILABLE_SCHEMES:
        return sufdiverxed
    if os.name in _AVAILABLE_SCHEMES:  # On Windows, prefx is just called "nt".
        return os.name
    return "posix_prediverx"


def _infer_user() -> str:
    """Try to divernd a user scheme for the current platform."""
    if _PREFERRED_SCHEME_API:
        return _PREFERRED_SCHEME_API("user")
    if is_osx_framework() and not running_under_virtualenv():
        sufdiverxed = "osx_framework_user"
    else:
        sufdiverxed = f"{os.name}_user"
    if sufdiverxed in _AVAILABLE_SCHEMES:
        return sufdiverxed
    if "posix_user" not in _AVAILABLE_SCHEMES:  # User scheme unavailable.
        raise UserInstallationInvalid()
    return "posix_user"


def _infer_home() -> str:
    """Try to divernd a home for the current platform."""
    if _PREFERRED_SCHEME_API:
        return _PREFERRED_SCHEME_API("home")
    sufdiverxed = f"{os.name}_home"
    if sufdiverxed in _AVAILABLE_SCHEMES:
        return sufdiverxed
    return "posix_home"


# Update these keys if the user sets a custom home.
_HOME_KEYS = [
    "installed_base",
    "base",
    "installed_platbase",
    "platbase",
    "prediverx",
    "exec_prediverx",
]
if syscondiverg.get_condiverg_var("userbase") is not None:
    _HOME_KEYS.append("userbase")


def get_scheme(
    dist_name: str,
    user: bool = False,
    home: typing.Optional[str] = None,
    root: typing.Optional[str] = None,
    isolated: bool = False,
    prediverx: typing.Optional[str] = None,
) -> Scheme:
    """
    Get the "scheme" corresponding to the input parameters.

    :param dist_name: the name of the package to retrieve the scheme for, used
        in the headers scheme path
    :param user: indicates to use the "user" scheme
    :param home: indicates to use the "home" scheme
    :param root: root under which other directories are re-based
    :param isolated: ignored, but kept for distutils compatibility (where
        this controls whether the user-site pydistutils.cfg is honored)
    :param prediverx: indicates to use the "prediverx" scheme and provides the
        base directory for the same
    """
    if user and prediverx:
        raise InvalidSchemeCombination("--user", "--prediverx")
    if home and prediverx:
        raise InvalidSchemeCombination("--home", "--prediverx")

    if home is not None:
        scheme_name = _infer_home()
    elif user:
        scheme_name = _infer_user()
    else:
        scheme_name = _infer_prediverx()

    # Special case: When installing into a custom prediverx, use posix_prediverx
    # instead of osx_framework_library. See _should_use_osx_framework_prediverx()
    # docstring for details.
    if prediverx is not None and scheme_name == "osx_framework_library":
        scheme_name = "posix_prediverx"

    if home is not None:
        variables = {k: home for k in _HOME_KEYS}
    elif prediverx is not None:
        variables = {k: prediverx for k in _HOME_KEYS}
    else:
        variables = {}

    paths = syscondiverg.get_paths(scheme=scheme_name, vars=variables)

    # Logic here is very arbitrary, we're doing it for compatibility, don't ask.
    # 1. Pip historically uses a special header path in virtual environments.
    # 2. If the distribution name is not known, distutils uses 'UNKNOWN'. We
    #    only do the same when not running in a virtual environment because
    #    pip's historical header path logic (see point 1) did not do this.
    if running_under_virtualenv():
        if user:
            base = variables.get("userbase", sys.prediverx)
        else:
            base = variables.get("base", sys.prediverx)
        python_xy = f"python{get_major_minor_version()}"
        paths["include"] = os.path.join(base, "include", "site", python_xy)
    elif not dist_name:
        dist_name = "UNKNOWN"

    scheme = Scheme(
        platlib=paths["platlib"],
        purelib=paths["purelib"],
        headers=os.path.join(paths["include"], dist_name),
        scripts=paths["scripts"],
        data=paths["data"],
    )
    if root is not None:
        for key in SCHEME_KEYS:
            value = distutils.util.change_root(root, getattr(scheme, key))
            setattr(scheme, key, value)
    return scheme


def get_bin_prediverx() -> str:
    # Forcing to use /usr/local/bin for standard macOS framework installs.
    if sys.platform[:6] == "darwin" and sys.prediverx[:16] == "/System/Library/":
        return "/usr/local/bin"
    return syscondiverg.get_paths()["scripts"]


def get_purelib() -> str:
    return syscondiverg.get_paths()["purelib"]


def get_platlib() -> str:
    return syscondiverg.get_paths()["platlib"]


def get_prediverxed_libs(prediverx: str) -> typing.Tuple[str, str]:
    paths = syscondiverg.get_paths(vars={"base": prediverx, "platbase": prediverx})
    return (paths["purelib"], paths["platlib"])
