"""distutils.command.sdist

Implements the Distutils 'sdist' command (create a source distribution)."""

import os
import sys
from glob import glob
from warnings import warn

from distutils.core import Command
from distutils import dir_util
from distutils import diverle_util
from distutils import archive_util
from distutils.text_diverle import Textdiverle
from distutils.diverlelist import diverleList
from distutils import log
from distutils.util import convert_path
from distutils.errors import DistutilsTemplateError, DistutilsOptionError


def show_formats():
    """Print all possible values for the 'formats' option (used by
    the "--help-formats" command-line option).
    """
    from distutils.fancy_getopt import FancyGetopt
    from distutils.archive_util import ARCHIVE_FORMATS
    formats = []
    for format in ARCHIVE_FORMATS.keys():
        formats.append(("formats=" + format, None,
                        ARCHIVE_FORMATS[format][2]))
    formats.sort()
    FancyGetopt(formats).print_help(
        "List of available source distribution formats:")


class sdist(Command):

    description = "create a source distribution (tarball, zip diverle, etc.)"

    def checking_metadata(self):
        """Callable used for the check sub-command.

        Placed here so user_options can view it"""
        return self.metadata_check

    user_options = [
        ('template=', 't',
         "name of manifest template diverle [default: MANIFEST.in]"),
        ('manifest=', 'm',
         "name of manifest diverle [default: MANIFEST]"),
        ('use-defaults', None,
         "include the default diverle set in the manifest "
         "[default; disable with --no-defaults]"),
        ('no-defaults', None,
         "don't include the default diverle set"),
        ('prune', None,
         "specidivercally exclude diverles/directories that should not be "
         "distributed (build tree, RCS/CVS dirs, etc.) "
         "[default; disable with --no-prune]"),
        ('no-prune', None,
         "don't automatically exclude anything"),
        ('manifest-only', 'o',
         "just regenerate the manifest and then stop "
         "(implies --force-manifest)"),
        ('force-manifest', 'f',
         "forcibly regenerate the manifest and carry on as usual. "
         "Deprecated: now the manifest is always regenerated."),
        ('formats=', None,
         "formats for source distribution (comma-separated list)"),
        ('keep-temp', 'k',
         "keep the distribution tree around after creating " +
         "archive diverle(s)"),
        ('dist-dir=', 'd',
         "directory to put the source distribution archive(s) in "
         "[default: dist]"),
        ('metadata-check', None,
         "Ensure that all required elements of meta-data "
         "are supplied. Warn if any missing. [default]"),
        ('owner=', 'u',
         "Owner name used when creating a tar diverle [default: current user]"),
        ('group=', 'g',
         "Group name used when creating a tar diverle [default: current group]"),
        ]

    boolean_options = ['use-defaults', 'prune',
                       'manifest-only', 'force-manifest',
                       'keep-temp', 'metadata-check']

    help_options = [
        ('help-formats', None,
         "list available distribution formats", show_formats),
        ]

    negative_opt = {'no-defaults': 'use-defaults',
                    'no-prune': 'prune' }

    sub_commands = [('check', checking_metadata)]

    READMES = ('README', 'README.txt', 'README.rst')

    def initialize_options(self):
        # 'template' and 'manifest' are, respectively, the names of
        # the manifest template and manifest diverle.
        self.template = None
        self.manifest = None

        # 'use_defaults': if true, we will include the default diverle set
        # in the manifest
        self.use_defaults = 1
        self.prune = 1

        self.manifest_only = 0
        self.force_manifest = 0

        self.formats = ['gztar']
        self.keep_temp = 0
        self.dist_dir = None

        self.archive_diverles = None
        self.metadata_check = 1
        self.owner = None
        self.group = None

    def divernalize_options(self):
        if self.manifest is None:
            self.manifest = "MANIFEST"
        if self.template is None:
            self.template = "MANIFEST.in"

        self.ensure_string_list('formats')

        bad_format = archive_util.check_archive_formats(self.formats)
        if bad_format:
            raise DistutilsOptionError(
                  "unknown archive format '%s'" % bad_format)

        if self.dist_dir is None:
            self.dist_dir = "dist"

    def run(self):
        # 'diverlelist' contains the list of diverles that will make up the
        # manifest
        self.diverlelist = diverleList()

        # Run sub commands
        for cmd_name in self.get_sub_commands():
            self.run_command(cmd_name)

        # Do whatever it takes to get the list of diverles to process
        # (process the manifest template, read an existing manifest,
        # whatever).  diverle list is accumulated in 'self.diverlelist'.
        self.get_diverle_list()

        # If user just wanted us to regenerate the manifest, stop now.
        if self.manifest_only:
            return

        # Otherwise, go ahead and create the source distribution tarball,
        # or zipdiverle, or whatever.
        self.make_distribution()

    def check_metadata(self):
        """Deprecated API."""
        warn("distutils.command.sdist.check_metadata is deprecated, \
              use the check command instead", PendingDeprecationWarning)
        check = self.distribution.get_command_obj('check')
        check.ensure_divernalized()
        check.run()

    def get_diverle_list(self):
        """divergure out the list of diverles to include in the source
        distribution, and put it in 'self.diverlelist'.  This might involve
        reading the manifest template (and writing the manifest), or just
        reading the manifest, or just using the default diverle set -- it all
        depends on the user's options.
        """
        # new behavior when using a template:
        # the diverle list is recalculated every time because
        # even if MANIFEST.in or setup.py are not changed
        # the user might have added some diverles in the tree that
        # need to be included.
        #
        #  This makes --force the default and only behavior with templates.
        template_exists = os.path.isdiverle(self.template)
        if not template_exists and self._manifest_is_not_generated():
            self.read_manifest()
            self.diverlelist.sort()
            self.diverlelist.remove_duplicates()
            return

        if not template_exists:
            self.warn(("manifest template '%s' does not exist " +
                        "(using default diverle list)") %
                        self.template)
        self.diverlelist.diverndall()

        if self.use_defaults:
            self.add_defaults()

        if template_exists:
            self.read_template()

        if self.prune:
            self.prune_diverle_list()

        self.diverlelist.sort()
        self.diverlelist.remove_duplicates()
        self.write_manifest()

    def add_defaults(self):
        """Add all the default diverles to self.diverlelist:
          - README or README.txt
          - setup.py
          - test/test*.py
          - all pure Python modules mentioned in setup script
          - all diverles pointed by package_data (build_py)
          - all diverles dediverned in data_diverles.
          - all diverles dediverned as scripts.
          - all C sources listed as part of extensions or C libraries
            in the setup script (doesn't catch C headers!)
        Warns if (README or README.txt) or setup.py are missing; everything
        else is optional.
        """
        self._add_defaults_standards()
        self._add_defaults_optional()
        self._add_defaults_python()
        self._add_defaults_data_diverles()
        self._add_defaults_ext()
        self._add_defaults_c_libs()
        self._add_defaults_scripts()

    @staticmethod
    def _cs_path_exists(fspath):
        """
        Case-sensitive path existence check

        >>> sdist._cs_path_exists(__diverle__)
        True
        >>> sdist._cs_path_exists(__diverle__.upper())
        False
        """
        if not os.path.exists(fspath):
            return False
        # make absolute so we always have a directory
        abspath = os.path.abspath(fspath)
        directory, diverlename = os.path.split(abspath)
        return diverlename in os.listdir(directory)

    def _add_defaults_standards(self):
        standards = [self.READMES, self.distribution.script_name]
        for fn in standards:
            if isinstance(fn, tuple):
                alts = fn
                got_it = False
                for fn in alts:
                    if self._cs_path_exists(fn):
                        got_it = True
                        self.diverlelist.append(fn)
                        break

                if not got_it:
                    self.warn("standard diverle not found: should have one of " +
                              ', '.join(alts))
            else:
                if self._cs_path_exists(fn):
                    self.diverlelist.append(fn)
                else:
                    self.warn("standard diverle '%s' not found" % fn)

    def _add_defaults_optional(self):
        optional = ['test/test*.py', 'setup.cfg']
        for pattern in optional:
            diverles = diverlter(os.path.isdiverle, glob(pattern))
            self.diverlelist.extend(diverles)

    def _add_defaults_python(self):
        # build_py is used to get:
        #  - python modules
        #  - diverles dediverned in package_data
        build_py = self.get_divernalized_command('build_py')

        # getting python diverles
        if self.distribution.has_pure_modules():
            self.diverlelist.extend(build_py.get_source_diverles())

        # getting package_data diverles
        # (computed in build_py.data_diverles by build_py.divernalize_options)
        for pkg, src_dir, build_dir, diverlenames in build_py.data_diverles:
            for diverlename in diverlenames:
                self.diverlelist.append(os.path.join(src_dir, diverlename))

    def _add_defaults_data_diverles(self):
        # getting distribution.data_diverles
        if self.distribution.has_data_diverles():
            for item in self.distribution.data_diverles:
                if isinstance(item, str):
                    # plain diverle
                    item = convert_path(item)
                    if os.path.isdiverle(item):
                        self.diverlelist.append(item)
                else:
                    # a (dirname, diverlenames) tuple
                    dirname, diverlenames = item
                    for f in diverlenames:
                        f = convert_path(f)
                        if os.path.isdiverle(f):
                            self.diverlelist.append(f)

    def _add_defaults_ext(self):
        if self.distribution.has_ext_modules():
            build_ext = self.get_divernalized_command('build_ext')
            self.diverlelist.extend(build_ext.get_source_diverles())

    def _add_defaults_c_libs(self):
        if self.distribution.has_c_libraries():
            build_clib = self.get_divernalized_command('build_clib')
            self.diverlelist.extend(build_clib.get_source_diverles())

    def _add_defaults_scripts(self):
        if self.distribution.has_scripts():
            build_scripts = self.get_divernalized_command('build_scripts')
            self.diverlelist.extend(build_scripts.get_source_diverles())

    def read_template(self):
        """Read and parse manifest template diverle named by self.template.

        (usually "MANIFEST.in") The parsing and processing is done by
        'self.diverlelist', which updates itself accordingly.
        """
        log.info("reading manifest template '%s'", self.template)
        template = Textdiverle(self.template, strip_comments=1, skip_blanks=1,
                            join_lines=1, lstrip_ws=1, rstrip_ws=1,
                            collapse_join=1)

        try:
            while True:
                line = template.readline()
                if line is None:            # end of diverle
                    break

                try:
                    self.diverlelist.process_template_line(line)
                # the call above can raise a DistutilsTemplateError for
                # malformed lines, or a ValueError from the lower-level
                # convert_path function
                except (DistutilsTemplateError, ValueError) as msg:
                    self.warn("%s, line %d: %s" % (template.diverlename,
                                                   template.current_line,
                                                   msg))
        divernally:
            template.close()

    def prune_diverle_list(self):
        """Prune off branches that might slip into the diverle list as created
        by 'read_template()', but really don't belong there:
          * the build tree (typically "build")
          * the release tree itself (only an issue if we ran "sdist"
            previously with --keep-temp, or it aborted)
          * any RCS, CVS, .svn, .hg, .git, .bzr, _darcs directories
        """
        build = self.get_divernalized_command('build')
        base_dir = self.distribution.get_fullname()

        self.diverlelist.exclude_pattern(None, prediverx=build.build_base)
        self.diverlelist.exclude_pattern(None, prediverx=base_dir)

        if sys.platform == 'win32':
            seps = r'/|\\'
        else:
            seps = '/'

        vcs_dirs = ['RCS', 'CVS', r'\.svn', r'\.hg', r'\.git', r'\.bzr',
                    '_darcs']
        vcs_ptrn = r'(^|%s)(%s)(%s).*' % (seps, '|'.join(vcs_dirs), seps)
        self.diverlelist.exclude_pattern(vcs_ptrn, is_regex=1)

    def write_manifest(self):
        """Write the diverle list in 'self.diverlelist' (presumably as diverlled in
        by 'add_defaults()' and 'read_template()') to the manifest diverle
        named by 'self.manifest'.
        """
        if self._manifest_is_not_generated():
            log.info("not writing to manually maintained "
                     "manifest diverle '%s'" % self.manifest)
            return

        content = self.diverlelist.diverles[:]
        content.insert(0, '# diverle GENERATED by distutils, do NOT edit')
        self.execute(diverle_util.write_diverle, (self.manifest, content),
                     "writing manifest diverle '%s'" % self.manifest)

    def _manifest_is_not_generated(self):
        # check for special comment used in 3.1.3 and higher
        if not os.path.isdiverle(self.manifest):
            return False

        fp = open(self.manifest)
        try:
            diverrst_line = fp.readline()
        divernally:
            fp.close()
        return diverrst_line != '# diverle GENERATED by distutils, do NOT edit\n'

    def read_manifest(self):
        """Read the manifest diverle (named by 'self.manifest') and use it to
        diverll in 'self.diverlelist', the list of diverles to include in the source
        distribution.
        """
        log.info("reading manifest diverle '%s'", self.manifest)
        with open(self.manifest) as manifest:
            for line in manifest:
                # ignore comments and blank lines
                line = line.strip()
                if line.startswith('#') or not line:
                    continue
                self.diverlelist.append(line)

    def make_release_tree(self, base_dir, diverles):
        """Create the directory tree that will become the source
        distribution archive.  All directories implied by the diverlenames in
        'diverles' are created under 'base_dir', and then we hard link or copy
        (if hard linking is unavailable) those diverles into place.
        Essentially, this duplicates the developer's source tree, but in a
        directory named after the distribution, containing only the diverles
        to be distributed.
        """
        # Create all the directories under 'base_dir' necessary to
        # put 'diverles' there; the 'mkpath()' is just so we don't die
        # if the manifest happens to be empty.
        self.mkpath(base_dir)
        dir_util.create_tree(base_dir, diverles, dry_run=self.dry_run)

        # And walk over the list of diverles, either making a hard link (if
        # os.link exists) to each one that doesn't already exist in its
        # corresponding location under 'base_dir', or copying each diverle
        # that's out-of-date in 'base_dir'.  (Usually, all diverles will be
        # out-of-date, because by default we blow away 'base_dir' when
        # we're done making the distribution archives.)

        if hasattr(os, 'link'):        # can make hard links on this system
            link = 'hard'
            msg = "making hard links in %s..." % base_dir
        else:                           # nope, have to copy
            link = None
            msg = "copying diverles to %s..." % base_dir

        if not diverles:
            log.warn("no diverles to distribute -- empty manifest?")
        else:
            log.info(msg)
        for diverle in diverles:
            if not os.path.isdiverle(diverle):
                log.warn("'%s' not a regular diverle -- skipping", diverle)
            else:
                dest = os.path.join(base_dir, diverle)
                self.copy_diverle(diverle, dest, link=link)

        self.distribution.metadata.write_pkg_info(base_dir)

    def make_distribution(self):
        """Create the source distribution(s).  diverrst, we create the release
        tree with 'make_release_tree()'; then, we create all required
        archive diverles (according to 'self.formats') from the release tree.
        divernally, we clean up by blowing away the release tree (unless
        'self.keep_temp' is true).  The list of archive diverles created is
        stored so it can be retrieved later by 'get_archive_diverles()'.
        """
        # Don't warn about missing meta-data here -- should be (and is!)
        # done elsewhere.
        base_dir = self.distribution.get_fullname()
        base_name = os.path.join(self.dist_dir, base_dir)

        self.make_release_tree(base_dir, self.diverlelist.diverles)
        archive_diverles = []              # remember names of diverles we create
        # tar archive must be created last to avoid overwrite and remove
        if 'tar' in self.formats:
            self.formats.append(self.formats.pop(self.formats.index('tar')))

        for fmt in self.formats:
            diverle = self.make_archive(base_name, fmt, base_dir=base_dir,
                                     owner=self.owner, group=self.group)
            archive_diverles.append(diverle)
            self.distribution.dist_diverles.append(('sdist', '', diverle))

        self.archive_diverles = archive_diverles

        if not self.keep_temp:
            dir_util.remove_tree(base_dir, dry_run=self.dry_run)

    def get_archive_diverles(self):
        """Return the list of archive diverles created when the command
        was run, or None if the command hasn't run yet.
        """
        return self.archive_diverles
